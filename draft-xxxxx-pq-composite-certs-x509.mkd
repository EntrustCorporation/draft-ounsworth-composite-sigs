---
title: Composite Postquantum Keys and Signatures in PKIX Certificates
abbrev: Composite Certs
# <!-- EDNOTE: Edits the draft name -->
docname: draft-xxxxx-pq-composite-certs-x509-00<
# <!-- date: 2012-01-13 -->
# <!-- date: 2012-01 -->
# <!-- date: 2012 -->

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: XXX WG
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
      -
        # [EDNOTE: We can have another Editor for this draft. Doesn't need to be Panos. -->
        ins: P. Kampanakis (Editor)
        name: Panos Kampanakis
        org: Cisco Systems
        #abbrev:
        # street:
        # city:
        #code:
        #country: USA
        #phone: +1
        #facsimile: +1
        email: pkampana@cisco.com

normative:
  RFC2119:
  RFC2986:
  RFC5280:
  RFC8174:

# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  I-D.draft-truskovsky-lamps-pq-hybrid-x509-01:

updates:
  RFC2986
  RFC5280

--- abstract
EDNOTE: This will be the abstract
<!-- End of Abstract -->


--- middle

# Change Log
EDNOTE: Remove this section before publication.

draft-xxxxx-pq-composite-certs-x509-00

* Beginning of the draft
<!-- End of Change Log section -->


# Introduction {#sec-intro}
EDNOTE: This will be the Introduction

During the transition to post-quantum cryptography, the deployment of cryptographic certificates using post-quantum algorithms will face two challenges

- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will also start to erode.  A relying party may learn some time after certificate deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Backwards compatibility: During the transition period, post-quantum algorithms will not be supported by all clients.

This document provides a mechanism to address algorithm strength uncertainty by providing formats for encoding multiple public keys into the existing public key field. The issue of backwards compatibility is left open to be addressed in separate draft(s).



<!-- End of Introduction section -->


# Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}} {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

This document defines the following terms:

* Traditional Certificate
* Composite certificate


EDNOTE: Look up the standard way to do glossaries in RFCs.
EDNOTE: I'm not sure we actually need these terms in this draft. We'll certainly need them in the Parallel PKIs draft.

## Traditional Certificate

An X.509 certificate conforming to {{RFC5280}}. In particular, a certificate containing a single subject public key, and a single issuer signature.

## Composite Certificate

An X.509 certificate containing two or more subject public keys and two or more issuer signatures as defined in this document.

# Composite Structures {#sec-composite-structs}

This section defines general structures for holding multiple subject public keys. ~~DESCRIBE DESIGN AND INTENT, SEQUENCE SO WE HAVE 2 OR MORE, BLAH BLAH~~ This addresses the "algorithm strength uncertainty" concern from {{sec-intro}}, though the authors note that this mechanism may have prove to have utility beyond the post-quantum migration.

Defining composite algorithm identifiers in this way avoids the exponential proliferation of OIDs needed for each pairwise combination of signature algorithms. This scheme also naturally extends from 2-keypair to n-keypair should a vendor find a use for this.

## CompositeAlgorithmIdentifier

We define the following new structure:

~~~ asn.1
CompositeAlgorithmIdentifier ::= SEQUENCE OF AlgorithmIdentifier
~~~
{: artwork-name="CompositeAlgorithmIdentifier-asn.1-structures"}


## CompositePublicKey {#sec-composite-pub-keys}

We define the following new structure:

~~~ asn.1
id-ce-CompositeAlgorithmIdentifier OBJECT IDENTIFIER ::= { OID }

CompositeAlgorithmIdentifier ::= SEQUENCE OF AlgorithmIdentifier
~~~
{: artwork-name="CompositePublicKey-asn.1-structures"}

The choice of `SEQUENCE OF BIT STRING` rather than `BIT STRING` is so the type-length-value encoding can solve the problem of variable-length public keys.

## CompositeSignatureValue {#sec-composite-sigs}
EDNOTE: This subsection describes the PKIX Composite Signatures and how they work. It will also explain how signing a certificate will work and how verification will work.

This section defines a general structure containing multiple signature values. ~~DESCRIBE DESIGN AND INTENT, SEQUENCE SO WE HAVE 2 OR MORE, BLAH BLAH~~ This addresses the "algorithm strength uncertainty" concern from {{sec-intro}}, though the authors note that this mechanism may have prove to have utility beyond the post-quantum migration.

We define the following new structure:

~~~ asn.1
id-ce-CompositeSignatureValue OBJECT IDENTIFIER ::= { OID }

CompositeSignatureValue ::= SEQUENCE OF BIT STRING
~~~
{: artwork-name="composite-sig-asn.1"}

The choice of `SEQUENCE OF BIT STRING` rather than `BIT STRING` is so the type-length-value encoding can solve the problem of variable-length signature values.

## SubjectPublicKeyInfo {#sec-composite-spki}

We re-define the `SubjectPublicKeyInfo` structure from {{RFC5280}} in the following way so that it is backwards-compatible with the definition given in {{RFC2986}} and {{RFC5280}}.

~~~ asn.1
SubjectPublicKeyInfo  ::=  CHOICE {
     SEQUENCE  {
          algorithm            AlgorithmIdentifier,
          subjectPublicKey     BIT STRING  },
     SEQUENCE  {
          algorithms           CompositeAlgorithmIdentifier,
          subjectPublicKeys    CompositePublicKey }
      }
~~~
{: artwork-name="composite-SubjectPublicKeyInfo-asn.1"}

The order MUST be consistent between the `algorithms` and the `subjectPublicKeys`, ie the 0th `CompositeAlgorithmIdentifier` MUST correspond to the 0th `CompositePublicKey` and so on.



# Composite Certificates {#sec-composite-certs}

We re-define the `Certificate` structure from {{RFC5280}} to use the composite public key and signature structures defined in {{sec-composite-pub-keys}} and {{sec-composite-sigs}}, respectively so that it is backwards-compatible with the definition given in {{RFC5280}}.


~~~ asn.1
Certificate  ::=  SEQUENCE  {
     tbsCertificate       TBSCertificate,
     signatureAlgorithm   CHOICE {
          AlgorithmIdentifier,
          CompositeAlgorithmIdentifier }
     signatureValue       CHOICE {
          BIT STRING,
          CompositeSignatureValue }
    }
~~~
{: artwork-name="composite-Certificate-asn.1"}

If either the `signatureAlgorithm` or `signatureValue` field contains the composite version, then the other MUST as well. The order MUST be consistent between the `signatureAlgorithm`s and the `signatureValue`s, ie the 0th `CompositeAlgorithmIdentifier` MUST correspond to the 0th `CompositeSignatureValue` and so on.

EDNOTE: We may also need to modify the definition of SubjectKeyIdentifier (https://tools.ietf.org/html/rfc5280#section-4.2.1.2) to be "as it is now, or the hash of the `CompositePublicKey`", being specific about which tags and length values are included in the hash.

## Validation {#sec-validation}

EDNOTE: talk about how composite certs are validated. Specifically address what happens if a client supports only some of the algs. Do we need to bring in a "SHOULD contain exactly 2 signatures, but MAY contain an arbitrary number if the vendor has a client-policy mechanism by which they can specify an algorithm verification policy" in {{sec-composite-sigs}} ?

EDNOTE: reference {sec-revokedalgorithms}

EDNOTE: be consistent through this doc "validation" vs "verificiton"

<!-- End of Composite Certificates section -->

# Certificate Enrollment {#sec-cert-enrollment}

Some aspects of certificate enrollment need to be modified to accommodate certificates with composite public keys and signatures.

## PCKS#10 {#sec-p10}

To place multiple public keys into a certificate signing request, the only modification needed to the PKCS#10 format is to replace the definition of `SubjectPublicKeyInfo ` given in {{RFC2986}} with the one given above in {{sec-composite-spki}}, which is backwards-compatible with the previous definition.

To place multiple signatures into a certificate signing request, we re-define the `CertificationRequest` from {{RFC2986}}.

~~~ asn.1
CertificationRequest ::= SEQUENCE {
        certificationRequestInfo CertificationRequestInfo,
        signatureAlgorithm   CHOICE {
             AlgorithmIdentifier{{ SignatureAlgorithms }},
             CompositeAlgorithmIdentifier }
        signatureValue       CHOICE {
             BIT STRING,
             CompositeSignatureValue }
       }
   }
~~~
{: artwork-name="composite-CertificationRequest-asn.1"}

If either the `signatureAlgorithm` or `signatureValue` field contains the composite version, then the other MUST as well. The order MUST be consistent between the `signatureAlgorithm`s and the `signatureValue`s, ie the 0th `CompositeAlgorithmIdentifier` MUST correspond to the 0th `CompositeSignatureValue` and so on.

EDNOTE: I'm not super familiar with RFC2986. Please double-check. Needs a thorough read-through of RFC2986 for other things that might need modification.



## Subsequent Enrollments with Overlapping Public Keys

Once an entity in the PKI has a valid composite certificate, it MAY send subsequent certificate enrollment requests for traditional certificates containing a public key from the composite certificate using the same DN. If the CA has previously issued one or more currently valid composite certificates for the same entity, containing that public key, and containing the same list of SANs, then it MUST include one "wtv_we_call_it" extension pointing to each such certificate, and MUST set the certificate expiry date to be not later than the expiry date of the referenced composite certificate with the {earliest expiry date?, latest expiry date?}.


# Certificate Revocation {#sec-revocation}
EDNOTE: This subsection will talk about compromises of keys, revocation and how recovation will be verified.

When a CA checks for key reuse of compromised keys, they SHOULD (MUST?) check each key individually, not a bit-for-bit match of the entire `CompositePublicKey` field.

## Certificate Revocation Lists (CRLs) {#sec-crl}
EDNOTE: A mention to OCSP implications should be made.

EDNOTE: The mechanism for globally revoking an algorithm should be mentioned, along with the practical suggestion that an algorithm MAY be globally revoked on one CRL but not an another (for example, a CA may design for a staged deprecation by placing certificates that will need to be valid beyond the deprecation of its algorithm on their own CRL).

EDNOTE: RFC5280 Section 5: "Environments with additional or special purpose requirements may build on this profile or may replace it."  ... include a sentence with the same language that we are doing this.


### CertificateList {#sec-certificatelist}

We re-define the `CertificateList` structure from {{RFC5280}} to use the composite signature structure defined in {{sec-composite-sigs}} so that it is backwards-compatible with the definition given in {{RFC5280}}.

~~~ asn.1
CertificateList  ::=  SEQUENCE  {
        tbsCertList          TBSCertList,
        signatureAlgorithm   CHOICE {
             AlgorithmIdentifier{{ SignatureAlgorithms }},
             CompositeAlgorithmIdentifier }
        signatureValue       CHOICE {
             BIT STRING,
             CompositeSignatureValue }
~~~
{: artwork-name="composite-CertificateList-asn.1"}

The `signatureAlgorithm` field MUST contain the same algorithm identifier as the signature field in the sequence tbsCertList {{sec-tbscertlist}}.

EDNOTE: should echo / update the text in RFC5280: 5.1.1.2.  signatureAlgorithm, and 5.1.1.3.  signatureValue


### TBS Cert List {#sec-tbscertlist}

We re-define the `TBSCertList` structure from {{RFC5280}} to use the composite signature structure defined in {{sec-composite-sigs}} so that it is backwards-compatible with the definition given in {{RFC5280}}.

~~~ asn.1
TBSCertList  ::=  SEQUENCE  {
        ...
        signature   CHOICE {
             AlgorithmIdentifier,
             CompositeAlgorithmIdentifier },
        ...
                                  }
~~~
{: artwork-name="composite-TBSCertList-asn.1"}

The "..." indicates that all other fields retain their definitions from {{RFC5280}} or elsewhere.

The `signature` field MUST contain the same algorithm identifier as the signatureAlgorithm field in the sequence CertificateList {{sec-certificatelist}}.


## Revoking an algorithm: Revoked Algorithms CRL Extension {#sec-revokedalgorithms}
Since a certificate may contain public keys and / or signatures, it is conceivable that even though a cryptographic algorithm is considered deprecated, a certificate may contain enough keys and signatures on alternative strong algorithms to warrant continuing to use that certificate in production. This section provides a CRL Extension by which a Certificate Authority can communicate the deprecation of an algorithm without causing a mass revocation of certificates. The goal is that by providing such a mechanism, the world can more quickly react to news of algorithm compromise compared to the need to revoke and re-issue all certificates using that algorithm.

EDNOTE: the above paragraph could use some polishing.
EDNOTE: choose a word for this: "Revoking an algorithm" vs "Deprecating an algorithm" vs something-else ?



This extension is OPTIONAL. If a CRL contains only composite certificates, then this extension SHOULD be designated as critical. If a CRL contains a mixture of composite and traditional certificates then it SHOULD be designated as non-critical.

If the Revoked Algorithms extension is present in the CRL covering an otherwise non-revoked certificate, then a client performing certificate validation MUST skip any signatures corresponding to a revoked algorithm; thus a certificate is valid only if it would have been valid had those Algorithm IDs and Signature Values been omitted from the certificate.

EDNOTE: I feel like the wording above can be tightened up to be more precise.

EDNOTE: mention OCSP; is it the OCSP Responder's responsibility or the client's to check this?

~~~ asn.1
id-ce-RevokedAlgorithms OBJECT IDENTIFIER ::= { OID }

RevokedAlgorithms ::= CompositeAlgorithmIdentifier
~~~
{: artwork-name="RevokedAlgorithm-asn.1"}


Note that a similar mechanism could be used on a per-certificate basis via CRL Entry Extensions, however the authors believe that giving the option to perform partial revocation of a certificate (ie revoking some keys or signatures but leaving the certificate as a whole valid) will greatly increase the complexity of certificate validation routines, thus increasing the chance of implementation bugs leading to vulnerabilities, without providing a commensurate amount of increased functionality. By not defining a new CRL Entry Extension, the following requirement is implied: if any key within a certificate warrant revocation, the entire certificate MUST be revoked using the existing revocation mechanisms.


## End-Entity Requested Revocation
EDNOTE: Before drafting this section, there's a debate to be had about whether a single-key revocation request has the authority to revoke a composite cert. Options:

* A signature from any key in the cert is sufficient to authorize revocation (this trivially requires no modification of protocols).
* A signature from any key in the cert using a non-revoked algorithm is sufficient to authorize revocation (this trivially requires no modification of protocols). *Note that if the cert contains no keys using non-revoked algorithms, then the cert is defacto revoked already. Mike votes for this option.*
* Signatures from all keys in the cert using non-revoked algorithms are required to authorize revocation (research needed into revocation protocols)
* Signatures from all keys in the cert are required to authorize revocation (research needed into revocation protocols)

EDNOTE: We may need to wade into modifications to the CMP / SCEP / EST protocols (but I really hope not).


<!-- End of Certificate Revocation section -->

# New Algorithm Identifiers
EDNOTE: This subsection defines the OIDs for the initial composite algorithm combinations we want to define.
EDNOTE: Merge with {{sec-iana}} ??

# In Practice {#sec-in-pract}
EDNOTE: This section will talk about practical issue of how these certificates will be used. For example it will talk about the size of these certs and cert chains. It will explain that if a cert in the chain is a Composite cert then the whole chain needs to be of Composite Certs. It will also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs. It will talk about overhead (size and processing). It will also discuss backwards compatibility. It could include a subsection about implementation considerations.

<!-- End of In Practice section -->

# Implications for existing standards

## RFC 2986
EDNOTE: summarize the updates to RFC 2986 (CSR / PKCS#10).


## RFC 5280
EDNOTE: summarize the updates to RFC 5280 (X.509).


## Cryptographic protocols
EDNOTE: This section talks about how protocols like (D)TLS and IKEv2 are affected by this specifications. It will not attempt to solve all these problems, but it will explain the rationale, how things will work and what open problems need to be solved. It will talk about implications of how to distinguish what cert chain to send. It will describe how signature_algorithms extension will be used in TLS. What is missing in TLS and IKEv2 like what and how to sign something with the two private keys. It will discuss overhead (size and processing) as in {{sec-in-pract}}. It will also discuss PKCS#10.

<!-- End of Implications for existing standards section -->

# IANA Considerations {#sec-iana}
EDNOTE: This section will include content only if new OIDs or IANA codepoints are asigned for it.

There are no IANA Considerations for this specification.
EDNOTE: ^^ ??

EDNOTE: We will need OIDs for these ASN.1 structures:

- CompositeAlgorithmIdentifier
- CompositePublicKey
- CompositeSignatureValue

<!-- End of IANA Considerations section -->


# Security Considerations
EDNOTE: This section includes the Security Considerations.

- Case: Only one key is compromised.
- Case: An entire algorithm is compromised.
- CA implementations need to be careful when checking for compromised key reuse: unpack the CompositePublicKey structure and compare individual keys.

<!-- End of Security Considerations section -->

# Appendices

## Comparison with draft-truskovsky-lamps-pq-hybrid-x509
EDNOTE: This section will explain the differences from {{I-D.truskovsky-lamps-pq-hybrid-x509}}. IPR Claims should be mentioned here if necessary. Other things to consider are the things we discussed in an email thread like simplicity and format, inadvertnt implementation errors, algorithm agility.

(MO): Move to appendix, or to a supporting document?

<!-- End of Comparison with draft-truskovsky-lamps-pq-hybrid-x509 section -->

# Contributors
EDNOTE: This section includes the contributors of this draft so the authors in the first page do not exceed five and thus violate RFC2223-bis. Example where this happens is RFC1122. We can have another Editor for this draft. Doesn't need to be Panos.

This document incorporates contributions and comments from a large
group of experts. The Editor would especially like to acknowledge the tireless
dedication of the following people, who attended many long
meetings and generated millions of bytes of electronic mail over the
past 3 years months in pursuit of this document:
Mike Ounsworth (Entrust Datacard), John Gray (Entrust Datacard),
Serge Mister (Entrust Datacard), Scott Fluhrer (Cisco Systems) and
Panos Kampanakis (Cisco Systems).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

<!-- End of Contributors section -->

# Acknowledgenents
EDNOTE: this section include all those that need to be acknowledged in the draft
