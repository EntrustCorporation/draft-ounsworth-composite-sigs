---
title: Composite Post-Quantum Keys and Signatures For Use In Internet PKI
abbrev: Composite Certs
# <!-- EDNOTE: Edits the draft name -->
docname: draft-xxxxx-pq-composite-sigs-00
# <!-- date: 2012-01-13 -->
# <!-- date: 2012-01 -->
# <!-- date: 2012 -->

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: XXX WG
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
      -
        # [EDNOTE: We can have another Editor for this draft. Doesn't need to be Panos. -->
        ins: P. Kampanakis (Editor)
        name: Panos Kampanakis
        org: Cisco Systems
        #abbrev:
        # street:
        # city:
        #code:
        #country: USA
        #phone: +1
        #facsimile: +1
        email: pkampana@cisco.com

normative:
  RFC2119:
  RFC2986:
  RFC5280:
  RFC8174:

# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  I-D.draft-truskovsky-lamps-pq-hybrid-x509-01:

updates:
  RFC2986
  RFC5280

# <!-- EDNOTE: does it update these anymore?? -->


# <!-- EDNOTE: Add RFC 3279? -->

--- abstract
EDNOTE: This will be the abstract
<!-- End of Abstract -->


--- middle

# Introduction {#sec-intro}

During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, but we will also not fully trust their post-quantum replacements until they have had sufficient scrutiny. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms. Even after the transition period, a composite approach may be advantageous as a single entity may have multiple public keys on different algorithms or strengths to address different use-cases, and a single signature may want to compase multiple of them together.

The deployment of composite public keys and signatures using post-quantum algorithms will face two challenges

- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will also start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Backwards compatibility: During the transition period, post-quantum algorithms will not be supported by all clients.

This document provides a mechanism to address algorithm strength uncertainty by providing formats for encoding multiple public keys and multiple signature values into existing public key and signature fields. The issue of backwards compatibility is left open to be addressed in separate draft(s).

This document is intended for general applicability anywhere that public key structures or digital signatures are used, but where specific design decisions needed to be made, the authors chose the variant that caused the least disruption to existing X.509 certificates, as defined in {{RFC5280}}.


<!-- End of Introduction section -->


# Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}} {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

# Definitions and notation

<!-- This section structure borrowed from RFC2986. -->

## Definitions

EDNOTE: A glossary of terms we define for this document, or terms that we borrow from other RFCs.

~~~
ALGORITHM: <!-- Borrowed straight from RFC2986 -->
            ENDOTE: need to clean up the link to "ITU-T Recommendation
            X.681 (1997)" ([11])
            An information object class defined in X.509 to
                   describe objects composed of an algorithm (a unique
                   object identifier) and its parameters (any ASN.1
                   type).  The values of objects in this class can be
                   represented by the ASN.1 type AlgorithmIdentifier{}.
                   ALGORITHM is defined as the "useful" information
                   object class TYPE-IDENTIFIER, specified in [11],
                   Annex A. This document is only concerned with
                   algorithms for producing digital signatures.

COMPONENT ALGORITHM:  A single basic algorithm which is contained
                      within a composite algorithm.

COMPOSITE ALGORITHM:  An algorithm which is a sequence of one or
                      more basic algorithm, as defined in section {{sec-composite-structs}}.
~~~
{: artwork-name="glossary"}


## Notation
No special notation is used in this document.

# Composite Structures {#sec-composite-structs}
In order for public keys and signatures to be composed of multiple algorithms, the respective structures defined in {{RFC2986}}, {{RFC5280}} (AND OTHERS??) need to be extended.
We define encodings of sequences of public keys and signature data which consist of a sequence of public keys and signatures from more basic signature algorithms (aka "component algorithms") such that these structures can be places into any existing public key or signature structure.

This section defines

  - Composite public key: A general structure for holding multiple public keys within a single public key data structure.

  - Composite signature: Data structures needed to make use of the Composite Signature signature algorithm (defined in {{sec-composite-signature-algorithm}}), which encapsulates signatures made with multiple public keys.

## Composite Public Key {#sec-composite-pub-keys}
A composite public key is a sequence of component public keys that are used together.  A composite public key is identified by the object identifier

~~~ asn.1
id-ce-compositePublicKey OBJECT IDENTIFIER ::= { OID }
~~~
{: artwork-name="CompositePublicKeyOID-asn.1-structures"}

The parameters field for this public key type MUST be absent.  The composite public key data is represented by the following structure:

~~~ asn.1
CompositePublicKey ::= SEQUENCE OF SubjectPublicKeyInfo
~~~
{: artwork-name="CompositePublicKey-asn.1-structures"}

where each element of the sequence is a SubjectPublicKeyInfo of a public key that MAY be used in conjunction with the other keys in the sequence.  When the public key must be provided in octet string or bit string format, the data structure is converted as specified in {{sec-encoding-composite-structures}}.

## Composite Signature Algorithm {#sec-composite-sigs}
The Composite Signature signature algorithm defined in {{sec-composite-signature-algorithm}} is identified by the following object identifier:

~~~ asn.1
id-ce-compositeSignature OBJECT IDENTIFIER ::= { OID }
~~~
{: artwork-name="CompositeSignature-asn.1-structures"}

The following algorithm parameters MUST be included when this identifier is used:

~~~ asn.1
CompositeSignatureAlgorithmParams ::= SEQUENCE OF AlgorithmIdentifier
~~~
{: artwork-name="CompositeSignatureParams-asn.1-structures"}

The algorithms in the sequence MUST correspond to the order in which the public keys are listed in the associated CompositePublicKey.

EDNOTE: We haven't defined the private key syntax, should we?  SRF: My opinion: no, as private keys do not appear within the certificate.

The Composite Signature algorithm output is the DER encoding of the following structure:

~~~ asn.1
id-ce-CompositeSignatureValue OBJECT IDENTIFIER ::= { OID }

CompositeSignatureValue ::= SEQUENCE OF BIT STRING
~~~
{: artwork-name="composite-sig-asn.1"}

Where each bit string within CompositeSignatureValue is a signature by one of the component signature algorithms.
The choice of `SEQUENCE OF BIT STRING` rather than `BIT STRING` is so the type-length-value encoding can solve the problem of variable-length signature values. The signature values in the sequence MUST correspond to the order in which the signature algorithms are listed in the corresponding CompositeSignatureAlgorithmParams, and in which the public keys are listed in the associated CompositePublicKey.

Defining composite algorithm parameters as above avoids the exponential proliferation of OIDs needed for each pairwise combination of signature algorithms. This scheme also naturally extends from 2-keypair to n-keypair should a vendor find a need for this.

# Encoding Composite Structures As Octet Strings and Bit Strings {#sec-encoding-composite-structures}
EDNOTE: Examples of how other specifications specify how a data structure is converted to a bit string can be found in RFC 2313, section 10.1.4, 3279 section 2.3.5, and RFC 4055, section 3.2.

Many specifications require that the composite public key and composite signature data structures defined above be represented by an octet string or bit string.  When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.  When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

# Composite Signature Algorithm {#sec-composite-signature-algorithm}
The Composite Signature signature algorithm produces a single composite signature by applying multiple signature algorithms to the input message, using multiple private keys, with the resulting signature effectively being the concatenation of the individual signatures.  This algorithm can address algorithm strength uncertainty by providing the verifier with parallel signatures from all the component signature algorithms used as part of the composite signature.

## Composite Signature Generation {#sec-comp-sig-gen}

~~~
Input:
     K1, K2, ..., Kn    The n private keys for the component signature
                        algorithms
     M                  Message to be signed, an octet string

Output:
     S                  Signature, an octet string

Signature Generation Procedure::
   1.  Sign the message separately using each component
       for i := 1 to n
           Si := Sign( Ki, M )
   2.  Encode the component signatures into an ASN.1 value of type
        Signature with the DER, where the type Signature has the syntax
       Signature ::= Sequence { S1, S2, ..., Sn }
     Let S be the DER encoding of the Signature
   3.  Output S
~~~
{: artwork-name="alg-composite-sig-gen"}

## Composite Signature Verification {#sec-comp-sig-verify}

This section provide a sample algorithm for validating composite signatures. Compliant implementations MUST return "Invalid signature" whenever the sample algorithm does, but MAY require more than one signature to be valid. Implementations MAY include additional policy mechanisms for determining which and how many algorithms must pass in order for the signature as a whole to be considered valid. See section {{sec-alg-revocation-policy}} for further discussion.

This section assumes the existence of a policy mechanism to revoke individual component algorithms. See section {{sec-alg-revocation-policy}} for further discussion.

EDNOTE: The corresponding "encrypt with a composite public key" logic is somewhat less obvious; a naive implementer might be tempted to encrypt the message with each public key separately, which is wrong.  Specifying the correct implementation of such an encryption scheme is out of scope for this document, but would be good work for someone in the standards community to pick up.

~~~
Input:
     P    Signer's composite public key
     M    Message whose signature is to be verified, an octet string
     S    Composite Signature to be verified
     A    Composite Algorithm identifier

Output:
    Validity      "Valid signature" (true) if the composite signature is
                  valid, "Invalid signature" (false) otherwise.

Signature Verification Procedure::
   1. Parse P, S, A into the component public keys, signatures,
      algorithm identifiers
     P1, P2, ..., Pk := Desequence( P )
     S1, S2, ..., Sk := Desequence( S )
     A1, A2, ..., Ak := Desequence( A )

    If Error during Desequencing, or the three sequences had different
    numbers of elements, then output "Invalid signature" and stop.

   2. Check each signature individually
     for i := 1 to k
        Check if Ai is a recognized algorithm,  if so then,
          Check if algorithm Ai has been revoked, if not then,
             if verify( Pi, M, Si ), then output "Valid signature"
                 and stop.
             else output "Invalid signature" and stop.

    3. Output "Invalid signature" (as no nonrevoked signature
       algorithms were available).
~~~
{: artwork-name="alg-one-must-pass-verif"}


<!-- End of Composite Signature Algorithm section -->

# Mechanisms to distribute verification policy to clients {#sec-alg-revocation-policy}

In the traditional world where public keys and signature comprise a single algorithm, the semantics of a signature and a verification are straight-forward: if the key is trusted (via public key pinning, a PKIX revocation check, etc) and the signature is valid, then the signed content can be trusted. However the semantics are less obvious in a world where public keys and signatures are composed of two or more algorithms; it is conceivable that even though a cryptographic algorithm is deprecated, a multi-algorithm signature may contain enough other trustworthy component algorithms to still be considered valid.

In this section addresses policy surrounding which and how many component algorithms must be valid in order for the signature as a whole to be valid. The authors ask for community feedback about whether how best to implement this, for example should it be specified by the signer at signing time, specified by an administrative authority such as a Certificate Authority, or left up to local policy of the verifier much as we do today? The authors believe that by specifying such a mechanism, the world will be able to more quickly react to news of algorithm compromise with a lower service disruption compared to the need to revoke and re-issue all certificates using that algorithm. However, we are not sure if the gains justify the added complexity.

We list here several such mechanisms that have come up in discussion, mainly focused around X.509 PKIs, provided here for the purposes of sparking debate.

## Local verifier policy

Much as we do today, this is left up to domain administrators and software vendors to implement the guidance of governing bodies on a system-by-system basis.

## Extra metadata in the signature

This policy information could be included in the signature structure, allowing the signer to specify it at signing time.

## Extra metadata in the certificate

This policy information could be included in a certificate via an X.509 v3 extension. This gives the Certificate Authority control, but has the drawback that updating the policy requires revoking and reissuing certificates.

## Policy certificate issued by the Certificate Authority

Certificate Authorities have the ability to issue policy certificates that specify the behaviour when verifying signatures performed by keys in certificates within the scope of the policy certificate.

This method has the advantage that policy is centrally-managed, and can be updated without needing to reissue any certificates, but has the drawback that not all PKI implementations support policy certificates.

## Policy constraints in a cross-certificate

This method behaves similarly to the policy certificate method above, but has better support across PKI implementations.

## Revoked Algorithms CRL Extension {#sec-revokedalgorithms}

Add an extension to CRLs so that in addition to revoking certificates, they can also revoke algorithms for all certificates within the scope of that CRL. Implemented with care, this could allow a single PKI to do a staged algorithm migration by only revoking the algorithm for one CRL group at a time.

~~~ asn.1
id-ce-RevokedAlgorithms OBJECT IDENTIFIER ::= { OID }

RevokedAlgorithms ::= SEQUENCE OF SEQUENCE  {
     algorithms              AlgorithmIdentifier,
     revocationDate          Time,
     crlEntryExtensions      Extensions OPTIONAL
                              -- if present, version MUST be v2
     }
~~~
{: artwork-name="RevokedAlgorithm-asn.1"}

EDNOTE: do we need the crlEntryExtensions field? If so, which ones from https://tools.ietf.org/html/rfc5280#section-5.3 are allowed here?

There may only be one `RevokedAlgorithms` extension in a CRL. This extension is OPTIONAL. If a CRL contains only composite certificates, then this extension SHOULD be designated as critical. If a CRL contains a mixture of composite and traditional certificates then it SHOULD be designated as non-critical.

If the Revoked Algorithms extension is present in the CRL covering an otherwise non-revoked certificate, then a client performing certificate validation MUST skip any signatures corresponding to a revoked algorithm; thus a certificate is valid only if it would have been valid had those Algorithm IDs and Signature Values been omitted from the certificate.

EDNOTE: I feel like the wording above can be tightened up to be more precise.

Once a algorithm has been marked as revoked on a given CRL, it MUST remain revoked on subsequent CRLs.
EDNOTE: ^^^ Is there corresponding wording about cert serial numbers on CRLs from RFC5280? If so, I'm not seeing it.


Note that a similar mechanism could be used on a per-certificate basis via CRL Entry Extensions, however the authors believe that giving operators the ability to perform partial revocation of a certificate (ie revoking some keys or signatures but leaving the certificate as a whole valid) will greatly increase the complexity of certificate validation routines, thus increasing the chance of both human error, and implementation bugs leading to vulnerabilities, without providing a commensurate amount of increased functionality. By not defining a new CRL Entry Extension, the following requirement is implied: if any key within a certificate warrant revocation, the entire certificate MUST be revoked using the existing revocation mechanisms (this does not apply when the algorithm is globally revoked for the entire scope of this CRL).

## Implicit Revocation {#sec-implicit-revocation}

A Composite Signature Algorithm is considered to be "implicitly revoked" if one of the following conditions are met, but the certificate is otherwise valid.

* A certificate using a single-key algorithm which is revoked within the scope of its CRL. In this case, signature verification SHOULD fail when performed by a compliant client, but of course will succeed when performed by a legacy client which is not aware of this CRL extension.
* All of the component algorithms are revoked within the scope if its CRL. In this case, signature verification MUST fail when performed by a compliant client, regardless of which verification algorithm is used.

At the time of an algorithm revocation, a certificate authority MAY revoke certificates meeting one ofd the above criteria (by placing them in the traditional `revokedCertificates` list) with a revocation reason of `keyCompromise`. OCSP responders SHOULD designate a certificate as revoked if it meets the above condition.

EDNOTE: read up on how OCSP works and mention the specific mechanism for the above. Also, is it the OCSP Responder's responsibility or the client's to check this?

# New Algorithm Identifiers
EDNOTE: This subsection defines the OIDs for the initial composite algorithm combinations we want to define.
EDNOTE: Merge with {{sec-iana}} ??

# In Practice {#sec-in-pract}
EDNOTE: This section will talk about practical issue of how these certificates will be used. For example it will talk about the size of these certs and cert chains. It will explain that if a cert in the chain is a Composite cert then the whole chain needs to be of Composite Certs. It will also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs. It will talk about overhead (size and processing). It will also discuss backwards compatibility. It could include a subsection about implementation considerations.

<!-- End of In Practice section -->

# Implications for existing standards

## RFC 2986
EDNOTE: summarize the updates to RFC 2986 (CSR / PKCS#10).


## RFC 5280
EDNOTE: summarize the updates to RFC 5280 (X.509).


## Cryptographic protocols
EDNOTE: This section talks about how protocols like (D)TLS and IKEv2 are affected by this specifications. It will not attempt to solve all these problems, but it will explain the rationale, how things will work and what open problems need to be solved. Obvious issues that need to be discussed:

- How does the protocol declare support for composite signatures?  TLS has hooks for declaring support for specific signature algorithms, however it would need to be extended, because the client would need to declare support for both the composite infrastructure, as well as for the various component signature algorithms.

- How does the protocol use the multiple keys.  The obvious way would be to have the server sign using its composite public key; is this sufficient.

- Overhead; including certificate size, signature processing time, and size of the signature.

- How to deal with crypto protocols that use public key encryption algorithms; this document only lists how to work with signature algorithms.  Encoding composite public keys is straightforward; encoding composite ciphertexts is less so - we decided to put that off to another draft.

<!-- End of Implications for existing standards section -->

# IANA Considerations {#sec-iana}
EDNOTE: This section will include content only if new OIDs or IANA codepoints are asigned for it.

There are no IANA Considerations for this specification.
EDNOTE: ^^ ?? Don't we need OIDs?

<!-- End of IANA Considerations section -->


# Security Considerations
EDNOTE: This section includes the Security Considerations.

- Case: Only one key is compromised.
- Case: An entire algorithm is compromised.
- CA implementations need to be careful when checking for compromised key reuse: unpack the CompositePublicKey structure and compare individual keys.

<!-- End of Security Considerations section -->

# Appendices

## Comparison with draft-truskovsky-lamps-pq-hybrid-x509
EDNOTE: This section will explain the differences from {{I-D.truskovsky-lamps-pq-hybrid-x509}}. IPR Claims should be mentioned here if necessary. Other things to consider are the things we discussed in an email thread like simplicity and format, inadvertnt implementation errors, algorithm agility.

<!-- End of Comparison with draft-truskovsky-lamps-pq-hybrid-x509 section -->



# Contributors
EDNOTE: This section includes the contributors of this draft so the authors in the first page do not exceed five and thus violate RFC2223-bis. Example where this happens is RFC1122. We can have another Editor for this draft. Doesn't need to be Panos.

This document incorporates contributions and comments from a large
group of experts. The Editor would especially like to acknowledge the tireless
dedication of the following people, who attended many long
meetings and generated millions of bytes of electronic mail over the
past 3 years months in pursuit of this document:
Mike Ounsworth (Entrust Datacard), John Gray (Entrust Datacard),
Serge Mister (Entrust Datacard), Scott Fluhrer (Cisco Systems) and
Panos Kampanakis (Cisco Systems).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

<!-- End of Contributors section -->

# Acknowledgenents
EDNOTE: this section include all those that need to be acknowledged in the draft
