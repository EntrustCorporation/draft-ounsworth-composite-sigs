---
title: Composite Post-Quantum Keys and Signatures For Use In Internet PKI
abbrev: Composite Certs
# <!-- EDNOTE: Edits the draft name -->
docname: draft-xxxxx-pq-composite-certs-x509-00
# <!-- date: 2012-01-13 -->
# <!-- date: 2012-01 -->
# <!-- date: 2012 -->

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: XXX WG
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
      -
        # [EDNOTE: We can have another Editor for this draft. Doesn't need to be Panos. -->
        ins: P. Kampanakis (Editor)
        name: Panos Kampanakis
        org: Cisco Systems
        #abbrev:
        # street:
        # city:
        #code:
        #country: USA
        #phone: +1
        #facsimile: +1
        email: pkampana@cisco.com

normative:
  RFC2119:
  RFC2986:
  RFC5280:
  RFC8174:

# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  I-D.draft-truskovsky-lamps-pq-hybrid-x509-01:

updates:
  RFC2986
  RFC5280
# <!-- EDNOTE: Add RFC 3279? -->

--- abstract
EDNOTE: This will be the abstract
<!-- End of Abstract -->


--- middle

# Change Log
EDNOTE: Remove this section before publication.

draft-xxxxx-pq-composite-certs-x509-00

* Beginning of the draft
<!-- End of Change Log section -->


# Introduction {#sec-intro}
EDNOTE: This will be the Introduction

During the transition to post-quantum cryptography, the deployment of cryptographic certificates using post-quantum algorithms will face two challenges

- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will also start to erode.  A relying party may learn some time after certificate deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Backwards compatibility: During the transition period, post-quantum algorithms will not be supported by all clients.

This document provides a mechanism to address algorithm strength uncertainty by providing formats for encoding multiple public keys and multiple signature values into existing public key and signature fields. The issue of backwards compatibility is left open to be addressed in separate draft(s).

<!-- End of Introduction section -->


# Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}} {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

This document defines the following terms:

* Traditional Certificate
* Composite certificate


EDNOTE: Look up the standard way to do glossaries in RFCs.
EDNOTE: I'm not sure we actually need these terms in this draft. We'll certainly need them in the Parallel PKIs draft.

## Traditional Certificate

An X.509 certificate conforming to {{RFC5280}}. In particular, a certificate containing a single subject public key, and a single issuer signature.

## Composite Certificate

An X.509 certificate containing two or more subject public keys and two or more issuer signatures as defined in this document.

# Composite Structures {#sec-composite-structs}
~~DESCRIBE DESIGN AND INTENT, SEQUENCE SO WE HAVE 2 OR MORE, BLAH BLAH~~
This section defines

  - A general structure for holding multiple public keys within a single public key data structure.

  - Data structures needed to make use of the Composite Signature signature algorithm (defined in {{sec-composite-signature-algorithm}}), which  encapsulates signatures made with multiple public keys.

These structures can be used to address the "algorithm strength uncertainty" concern from {{sec-intro}}, though the authors note that this mechanism may prove to have utility beyond the post-quantum migration.

## Composite Public Key {#sec-composite-pub-keys}
A composite public key is a sequence of public keys that are generally used together.  A composite public key is identified by the object identifier

~~~ asn.1
id-ce-compositePublicKey OBJECT IDENTIFIER ::= { OID }
~~~
{: artwork-name="CompositePublicKeyOID-asn.1-structures"}

The parameters field for this public key type MUST be absent.  The composite public key data is represented by the following structure:

~~~ asn.1
CompositePublicKey ::= SEQUENCE OF SubjectPublicKeyInfo
~~~
{: artwork-name="CompositePublicKey-asn.1-structures"}

where each element of the sequence is a SubjectPublicKeyInfo of a public key that MAY be used in conjunction with the other keys in the sequence.  When the public key must be provided in octet string or bit string format, the data structure is converted as specified in {{sec-encoding-composite-structures}}.

## Composite Signature Algorithm Structures {#sec-composite-sigs}
The Composite Signature signature algorithm defined in {{sec-composite-signature-algorithm}} is identified by the following object identifier:

~~~ asn.1
id-ce-compositeSignature OBJECT IDENTIFIER ::= { OID }
~~~
{: artwork-name="CompositeSignature-asn.1-structures"}

The following algorithm parameters MUST be included when this identifier is used:

~~~ asn.1
CompositeSignatureAlgorithmParams ::= SEQUENCE OF AlgorithmIdentifier
~~~
{: artwork-name="CompositeSignatureParams-asn.1-structures"}

The algorithms in the sequence MUST correspond to the order in which the public keys are listed in the associated CompositePublicKey.

EDNOTE: We haven't defined the private key syntax, but I think we should

The Composite Signature algorithm output is the DER encoding of the following structure:

EDNOTE: Does this structure need an OID, or is it sufficient that the algorithm have an OID as defined above?

~~~ asn.1
id-ce-CompositeSignatureValue OBJECT IDENTIFIER ::= { OID }

CompositeSignatureValue ::= SEQUENCE OF BIT STRING
~~~
{: artwork-name="composite-sig-asn.1"}

The choice of `SEQUENCE OF BIT STRING` rather than `BIT STRING` is so the type-length-value encoding can solve the problem of variable-length signature values. The signature values in the sequence MUST correspond to the order in which the signature algorithms are listed in the corresponding CompositeSignatureAlgorithmParams, and in which the public keys are listed in the associated CompositePublicKey.


Defining composite algorithm parameters as above avoids the exponential proliferation of OIDs needed for each pairwise combination of signature algorithms. This scheme also naturally extends from 2-keypair to n-keypair should a vendor find a use for this.

# Encoding Composite Structures As Octet Strings and Bit Strings {#sec-encoding-composite-structures}
EDNOTE: Examples of how other specifications specify how a data structure is converted to a bit string can be found in RFC 2313, section 10.1.4, 3279 section 2.3.5, and RFC 4055, section 3.2.

Many specifications require that the composite public key and composite signature data structures defined above be represented by an octet string or bit string.  When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.  When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

# Composite Signature Algorithm {#sec-composite-signature-algorithm}
The Composite Signature signature algorithm produces a single composite signature by applying multiple signature algorithms to the input data, using multiple public keys, with the resulting signature effectively being the concatenation of the individual signatures.  This algorithm can address algorithm strength uncertainty by leveraging the strength of all of the signature algorithms used as part of the composite signature.

## Signature Generation

Input:

Output:

Signature Generation Procedure:

## Signature Verification

Input:

Output:

Signature Verification Procedure:

# New Algorithm Identifiers
EDNOTE: This subsection defines the OIDs for the initial composite algorithm combinations we want to define.
EDNOTE: Merge with {{sec-iana}} ??

# In Practice {#sec-in-pract}
EDNOTE: This section will talk about practical issue of how these certificates will be used. For example it will talk about the size of these certs and cert chains. It will explain that if a cert in the chain is a Composite cert then the whole chain needs to be of Composite Certs. It will also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs. It will talk about overhead (size and processing). It will also discuss backwards compatibility. It could include a subsection about implementation considerations.

<!-- End of In Practice section -->

# Implications for existing standards

## RFC 2986
EDNOTE: summarize the updates to RFC 2986 (CSR / PKCS#10).


## RFC 5280
EDNOTE: summarize the updates to RFC 5280 (X.509).


## Cryptographic protocols
EDNOTE: This section talks about how protocols like (D)TLS and IKEv2 are affected by this specifications. It will not attempt to solve all these problems, but it will explain the rationale, how things will work and what open problems need to be solved. It will talk about implications of how to distinguish what cert chain to send. It will describe how signature_algorithms extension will be used in TLS. What is missing in TLS and IKEv2 like what and how to sign something with the two private keys. It will discuss overhead (size and processing) as in {{sec-in-pract}}. It will also discuss PKCS#10.

<!-- End of Implications for existing standards section -->

# IANA Considerations {#sec-iana}
EDNOTE: This section will include content only if new OIDs or IANA codepoints are asigned for it.

There are no IANA Considerations for this specification.
EDNOTE: ^^ ??

EDNOTE: We will need OIDs for these ASN.1 structures:

- CompositeAlgorithmIdentifier
- CompositePublicKey
- CompositeSignatureValue

<!-- End of IANA Considerations section -->


# Security Considerations
EDNOTE: This section includes the Security Considerations.

- Case: Only one key is compromised.
- Case: An entire algorithm is compromised.
- CA implementations need to be careful when checking for compromised key reuse: unpack the CompositePublicKey structure and compare individual keys.

<!-- End of Security Considerations section -->

# Appendices

## Comparison with draft-truskovsky-lamps-pq-hybrid-x509
EDNOTE: This section will explain the differences from {{I-D.truskovsky-lamps-pq-hybrid-x509}}. IPR Claims should be mentioned here if necessary. Other things to consider are the things we discussed in an email thread like simplicity and format, inadvertnt implementation errors, algorithm agility.

(MO): Move to appendix, or to a supporting document?

<!-- End of Comparison with draft-truskovsky-lamps-pq-hybrid-x509 section -->

# Contributors
EDNOTE: This section includes the contributors of this draft so the authors in the first page do not exceed five and thus violate RFC2223-bis. Example where this happens is RFC1122. We can have another Editor for this draft. Doesn't need to be Panos.

This document incorporates contributions and comments from a large
group of experts. The Editor would especially like to acknowledge the tireless
dedication of the following people, who attended many long
meetings and generated millions of bytes of electronic mail over the
past 3 years months in pursuit of this document:
Mike Ounsworth (Entrust Datacard), John Gray (Entrust Datacard),
Serge Mister (Entrust Datacard), Scott Fluhrer (Cisco Systems) and
Panos Kampanakis (Cisco Systems).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

<!-- End of Contributors section -->

# Acknowledgenents
EDNOTE: this section include all those that need to be acknowledged in the draft
