



XXX WG                                            P. Kampanakis (Editor)
Internet-Draft                                             Cisco Systems
Updates: RFC2986 RFC5280 (if approved)                 February 02, 2019
Intended status: Standards Track
Expires: August 6, 2019


   Composite Post-Quantum Keys and Signatures For Use In Internet PKI
                 draft-xxxxx-pq-composite-certs-x509-00

Abstract

   EDNOTE: This will be the abstract

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 6, 2019.

Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Kampanakis (Editor)      Expires August 6, 2019                 [Page 1]

Internet-Draft               Composite Certs               February 2019


Table of Contents

   1.  Change Log  . . . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3
   4.  Composite Structures  . . . . . . . . . . . . . . . . . . . .   3
     4.1.  Composite Public Key  . . . . . . . . . . . . . . . . . .   3
     4.2.  Composite Signature Algorithm Structures  . . . . . . . .   4
   5.  Encoding Composite Structures As Octet Strings and Bit
       Strings . . . . . . . . . . . . . . . . . . . . . . . . . . .   5
   6.  Composite Signature Algorithm . . . . . . . . . . . . . . . .   5
     6.1.  Composite Signature Generation  . . . . . . . . . . . . .   5
     6.2.  Composite Signature Verification  . . . . . . . . . . . .   6
       6.2.1.  "One Must Pass" Verification Algorithm  . . . . . . .   6
       6.2.2.  "All Must Pass" Verification Algorithm  . . . . . . .   7
     6.3.  Revoking an algorithm: Revoked Algorithms CRL Extension .   7
     6.4.  Implicit Revocation . . . . . . . . . . . . . . . . . . .   9
   7.  New Algorithm Identifiers . . . . . . . . . . . . . . . . . .   9
   8.  In Practice . . . . . . . . . . . . . . . . . . . . . . . . .  10
   9.  Implications for existing standards . . . . . . . . . . . . .  10
     9.1.  RFC 2986  . . . . . . . . . . . . . . . . . . . . . . . .  10
     9.2.  RFC 5280  . . . . . . . . . . . . . . . . . . . . . . . .  10
     9.3.  Cryptographic protocols . . . . . . . . . . . . . . . . .  10
   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  10
   11. Security Considerations . . . . . . . . . . . . . . . . . . .  11
   12. Appendices  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     12.1.  Comparison with draft-truskovsky-lamps-pq-hybrid-x509  .  11
     12.2.  Composite Encryption Algorithm . . . . . . . . . . . . .  11
   13. Contributors  . . . . . . . . . . . . . . . . . . . . . . . .  11
   14. Acknowledgenents  . . . . . . . . . . . . . . . . . . . . . .  12
   15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  12
     15.1.  Normative References . . . . . . . . . . . . . . . . . .  12
     15.2.  Informative References . . . . . . . . . . . . . . . . .  12
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  13

1.  Change Log

   EDNOTE: Remove this section before publication.

   draft-xxxxx-pq-composite-certs-x509-00

   o  Beginning of the draft

2.  Introduction

   During the transition to post-quantum cryptography, the deployment of
   cryptographic certificates using post-quantum algorithms will face
   two challenges



Kampanakis (Editor)      Expires August 6, 2019                 [Page 2]

Internet-Draft               Composite Certs               February 2019


   o  Algorithm strength uncertainty: During the transition period, some
      post-quantum signature and encryption algorithms will not be fully
      trusted, while also the trust in legacy public key algorithms will
      also start to erode.  A relying party may learn some time after
      deployment that a public key algorithm has become untrustworthy,
      but in the interim, they may not know which algorithm an adversary
      has compromised.

   o  Backwards compatibility: During the transition period, post-
      quantum algorithms will not be supported by all clients.

   This document provides a mechanism to address algorithm strength
   uncertainty by providing formats for encoding multiple public keys
   and multiple signature values into existing public key and signature
   fields.  The issue of backwards compatibility is left open to be
   addressed in separate draft(s).

3.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

4.  Composite Structures

   ~~DESCRIBE DESIGN AND INTENT, SEQUENCE SO WE HAVE 2 OR MORE, BLAH
   BLAH~~ This section defines

   o  A general structure for holding multiple public keys within a
      single public key data structure.

   o  Data structures needed to make use of the Composite Signature
      signature algorithm (defined in Section 6), which encapsulates
      signatures made with multiple public keys.

   These structures can be used to address the "algorithm strength
   uncertainty" concern from Section 2, though the authors note that
   this mechanism may prove to have utility beyond the post-quantum
   migration.

4.1.  Composite Public Key

   A composite public key is a sequence of public keys that are
   generally used together.  A composite public key is identified by the
   object identifier




Kampanakis (Editor)      Expires August 6, 2019                 [Page 3]

Internet-Draft               Composite Certs               February 2019


   id-ce-compositePublicKey OBJECT IDENTIFIER ::= { OID }

   The parameters field for this public key type MUST be absent.  The
   composite public key data is represented by the following structure:

   CompositePublicKey ::= SEQUENCE OF SubjectPublicKeyInfo

   where each element of the sequence is a SubjectPublicKeyInfo of a
   public key that MAY be used in conjunction with the other keys in the
   sequence.  When the public key must be provided in octet string or
   bit string format, the data structure is converted as specified in
   Section 5.

4.2.  Composite Signature Algorithm Structures

   The Composite Signature signature algorithm defined in Section 6 is
   identified by the following object identifier:

   id-ce-compositeSignature OBJECT IDENTIFIER ::= { OID }

   The following algorithm parameters MUST be included when this
   identifier is used:

   CompositeSignatureAlgorithmParams ::= SEQUENCE OF AlgorithmIdentifier

   The algorithms in the sequence MUST correspond to the order in which
   the public keys are listed in the associated CompositePublicKey.

   EDNOTE: We haven't defined the private key syntax, but I think we
   should

   The Composite Signature algorithm output is the DER encoding of the
   following structure:

   EDNOTE: Does this structure need an OID, or is it sufficient that the
   algorithm have an OID as defined above?

   id-ce-CompositeSignatureValue OBJECT IDENTIFIER ::= { OID }

   CompositeSignatureValue ::= SEQUENCE OF BIT STRING

   The choice of "SEQUENCE OF BIT STRING" rather than "BIT STRING" is so
   the type-length-value encoding can solve the problem of variable-
   length signature values.  The signature values in the sequence MUST
   correspond to the order in which the signature algorithms are listed
   in the corresponding CompositeSignatureAlgorithmParams, and in which
   the public keys are listed in the associated CompositePublicKey.




Kampanakis (Editor)      Expires August 6, 2019                 [Page 4]

Internet-Draft               Composite Certs               February 2019


   Defining composite algorithm parameters as above avoids the
   exponential proliferation of OIDs needed for each pairwise
   combination of signature algorithms.  This scheme also naturally
   extends from 2-keypair to n-keypair should a vendor find a use for
   this.

5.  Encoding Composite Structures As Octet Strings and Bit Strings

   EDNOTE: Examples of how other specifications specify how a data
   structure is converted to a bit string can be found in RFC 2313,
   section 10.1.4, 3279 section 2.3.5, and RFC 4055, section 3.2.

   Many specifications require that the composite public key and
   composite signature data structures defined above be represented by
   an octet string or bit string.  When an octet string is required, the
   DER encoding of the composite data structure SHALL be used directly.
   When a bit string is required, the octets of the DER encoded
   composite data structure SHALL be used as the bits of the bit string,
   with the most significant bit of the first octet becoming the first
   bit, and so on, ending with the least significant bit of the last
   octet becoming the last bit of the bit string.

6.  Composite Signature Algorithm

   The Composite Signature signature algorithm produces a single
   composite signature by applying multiple signature algorithms to the
   input message, using multiple private keys, with the resulting
   signature effectively being the concatenation of the individual
   signatures.  This algorithm can address algorithm strength
   uncertainty by providing the verifier with parallel signatures from
   all of the signature algorithms used as part of the composite
   signature.

6.1.  Composite Signature Generation

   Input: K1, K2, ..., Kn The n private keys for the component signature
   algorithms M Message to be signed, an octet string

   Output: S signature, an octet string

   Signature Generation Procedure:: 1.  Sign the message separately
   using each component for i := 1 to n Si := Sign( Ki, M ) 2.  Encode
   the component signatures into an ASN.1 value of type Signature with
   the DER, where the type Signature has the syntax Signature ::=
   Sequence { S1, S2, ..., Sn } Let S be the DER encoding of the
   Signature 3.  Output S





Kampanakis (Editor)      Expires August 6, 2019                 [Page 5]

Internet-Draft               Composite Certs               February 2019


6.2.  Composite Signature Verification

   The choice of how many component signatures must be valid in order
   for the composite signature as a whole to be valid is a policy
   decision to be made by the verifier.

   Compliant implementations MUST return "Invalid signature" whenever
   the "One Must Pass" algorithm does, but MAY require more than one
   signature to be valid.  It is RECOMMENDED to implement the "All Must
   Pass" algorithm.

   EDNOTE: The corresponding "encrypt with a composite public key" logic
   is somewhat less obvious; a naive implementer might be tempted to
   encrypt the message with each public key separately, which is wrong.
   Should we include the correct pseudocode in an appendix, even though
   the ciphertext would never appear in a certificate?

6.2.1.  "One Must Pass" Verification Algorithm

   Input: P Signer's composite public key M Message whose signature is
   to be verified, an octet string S Composite Signature to be verified
   A Composite Algorithm identifier

   Output: Validity "Valid signature" (true) if the composite signature
   is valid, "Invalid signature" (false) otherwise.

   Signature Verification Procedure:: 1.  Parse P, S, A into the
   component public keys, signatures, algorithm identifiers P1, P2, ...,
   Pk := Desequence( P ) S1, S2, ..., Sk := Desequence( S ) A1, A2, ...,
   Ak := Desequence( A )

If Error during Desequencing, or the three sequences had different numbers of elements, then output "Invalid signature" and stop.

   1.  Check each signature individually ValidSignature := false; for i
       := 1 to k Check if Ai is a recognized algorithm, if so if NOT
       verify( Pi, M, Si ) output "Invalid signature" and stop Check if
       algorithm Ai has been revoked.  If not, then ValidSignature |=
       true

   3. Succeed if at least one non-revoked signature algorithm validated
    if ValidSignature, then output "Valid signature"
    otherwise output "Invalid signature"

   EDNOTE: In order to achieve timing-invariance, all signatures must be
   verified, even after a successful signatures is found.

   EDNOTE (Scott): The above signature algorithm passes if at least one
   "trusted" algorithm passes.  Obviously, we could be more specific



Kampanakis (Editor)      Expires August 6, 2019                 [Page 6]

Internet-Draft               Composite Certs               February 2019


   (e.g. "one traditional and one postquantum algorithm"), however I
   don't believe that the additional complexity is justified.  My
   philosophy is that it's easier to add complexity to a draft RFC than
   to remove it, so the first cut should default to simplicity, and if
   the WG decides they'd prefer a more complex solution, so be it...

   EDNOTE (Mike): I have provided the "All must pass" and "One must
   pass" with the comment that "other variants are possible at the
   discretion of the verifier".

6.2.2.  "All Must Pass" Verification Algorithm

   Input: P Signer's composite public key M Message whose signature is
   to be verified, an octet string S Composite Signature to be verified
   A Composite Algorithm identifier

   Output: Validity "Valid signature" (true) if the composite signature
   is valid, "Invalid signature" (false) otherwise.

   Signature Verification Procedure: 1.  Parse P, S, A into the
   component public keys, signatures, algorithm identifiers P1, P2, ...,
   Pk := Desequence( P ) S1, S2, ..., Sk := Desequence( S ) A1, A2, ...,
   Ak := Desequence( A )

  If Error during Desequencing, or the three sequences had different numbers of elements, then output "Invalid signature" and stop.

   1.  Check each signature individually ValidSignature := false; for i
       := 1 to k Check if Ai is a recognized algorithm, if so if NOT
       verify( Pi, M, Si ) output "Invalid signature" and stop Check if
       algorithm Ai has been revoked.  If not, then ValidSignature &=
       true else output "Invalid signature"

   3. Succeed if all non-revoked signature algorithms validated
      if ValidSignature, then output "Valid signature"
      otherwise output "Invalid signature"

   EDNOTE: In order to achieve timing-invariance, all signatures must be
   verified, even after a successful signatures is found.

   EDNOTE: There is no point in trying to preserve timing-invariance in
   the case where one or more component algorithms are not supported.

6.3.  Revoking an algorithm: Revoked Algorithms CRL Extension

   Since a certificate may contain public keys and / or signatures, it
   is conceivable that even though a cryptographic algorithm is
   considered deprecated, a certificate may contain enough keys and
   signatures on alternative strong algorithms to warrant continuing to



Kampanakis (Editor)      Expires August 6, 2019                 [Page 7]

Internet-Draft               Composite Certs               February 2019


   use that certificate in production.  This section provides a CRL
   Extension by which a Certificate Authority can communicate the
   deprecation of an algorithm without causing a mass revocation of
   certificates.  The goal is that by providing such a mechanism, the
   world can more quickly react to news of algorithm compromise compared
   to the need to revoke and re-issue all certificates using that
   algorithm.

   EDNOTE: the above paragraph could use some polishing.  EDNOTE: agree
   a word for this: "Revoking an algorithm" vs "Deprecating an
   algorithm" vs something-else ?

   id-ce-RevokedAlgorithms OBJECT IDENTIFIER ::= { OID }

   RevokedAlgorithms ::= SEQUENCE OF SEQUENCE  {
        algorithms              AlgorithmIdentifier,
        revocationDate          Time,
        crlEntryExtensions      Extensions OPTIONAL
                                 -- if present, version MUST be v2
        }

   EDNOTE: do we need the crlEntryExtensions field?  If so, which ones
   from https://tools.ietf.org/html/rfc5280#section-5.3 are allowed
   here?

   There may only be one "RevokedAlgorithms" extension in a CRL.  This
   extension is OPTIONAL.  If a CRL contains only composite
   certificates, then this extension SHOULD be designated as critical.
   If a CRL contains a mixture of composite and traditional certificates
   then it SHOULD be designated as non-critical.

   If the Revoked Algorithms extension is present in the CRL covering an
   otherwise non-revoked certificate, then a client performing
   certificate validation MUST skip any signatures corresponding to a
   revoked algorithm; thus a certificate is valid only if it would have
   been valid had those Algorithm IDs and Signature Values been omitted
   from the certificate.

   EDNOTE: I feel like the wording above can be tightened up to be more
   precise.

   Once a algorithm has been marked as revoked on a given CRL, it MUST
   remain revoked on subsequent CRLs.  EDNOTE: ^^^ Is there
   corresponding wording about cert serial numbers on CRLs from RFC5280?
   If so, I'm not seeing it.

   Note that a similar mechanism could be used on a per-certificate
   basis via CRL Entry Extensions, however the authors believe that



Kampanakis (Editor)      Expires August 6, 2019                 [Page 8]

Internet-Draft               Composite Certs               February 2019


   giving operators the ability to perform partial revocation of a
   certificate (ie revoking some keys or signatures but leaving the
   certificate as a whole valid) will greatly increase the complexity of
   certificate validation routines, thus increasing the chance of both
   human error, and implementation bugs leading to vulnerabilities,
   without providing a commensurate amount of increased functionality.
   By not defining a new CRL Entry Extension, the following requirement
   is implied: if any key within a certificate warrant revocation, the
   entire certificate MUST be revoked using the existing revocation
   mechanisms (this does not apply when the algorithm is globally
   revoked for the entire scope of this CRL).

6.4.  Implicit Revocation

   EDNOTE: This section needs to be re-worded to reflect "Signature
   Algorithm" rather than "Certificate".

   A Composite Signature Algorithm is considered to be "implicitly
   revoked" if one of the following conditions are met, but the
   certificate is otherwise valid.

   o  All of the algorithms listed in the certificate's
      "signatureAlgorithm" are revoked.  In this case certificate chain
      validation of this certificates will fail when performed by a
      compliant client.

   o  All of the algorithms listed in the certificate's
      "SubjectPublicKeyInfo" are revoked.  In this case validation of a
      signature performed by the private keys corresponding to the
      public keys listed in this certificate will fail when performed by
      a compliant client.

   At the time of an algorithm revocation, a certificate authority MAY
   revoke certificates meeting either of the above criteria (by placing
   them in the "revokedCertificates" list) with a revocation reason of
   "keyCompromise".  OCSP responders SHOULD designate a certificate as
   revoked if it meets either of the above conditions.

   EDNOTE: read up on how OCSP works and mention the specific mechanism
   for the above.  Also, is it the OCSP Responder's responsibility or
   the client's to check this?

7.  New Algorithm Identifiers

   EDNOTE: This subsection defines the OIDs for the initial composite
   algorithm combinations we want to define.  EDNOTE: Merge with
   Section 10 ??




Kampanakis (Editor)      Expires August 6, 2019                 [Page 9]

Internet-Draft               Composite Certs               February 2019


8.  In Practice

   EDNOTE: This section will talk about practical issue of how these
   certificates will be used.  For example it will talk about the size
   of these certs and cert chains.  It will explain that if a cert in
   the chain is a Composite cert then the whole chain needs to be of
   Composite Certs.  It will also explain that the root CA cert does not
   have to be of the same algorithms.  The root cert SHOULD NOT be
   transferred in the authentication exchange to save transport overhead
   and thus it can be different than the intermediate and leaf certs.
   It will talk about overhead (size and processing).  It will also
   discuss backwards compatibility.  It could include a subsection about
   implementation considerations.

9.  Implications for existing standards

9.1.  RFC 2986

   EDNOTE: summarize the updates to RFC 2986 (CSR / PKCS#10).

9.2.  RFC 5280

   EDNOTE: summarize the updates to RFC 5280 (X.509).

9.3.  Cryptographic protocols

   EDNOTE: This section talks about how protocols like (D)TLS and IKEv2
   are affected by this specifications.  It will not attempt to solve
   all these problems, but it will explain the rationale, how things
   will work and what open problems need to be solved.  It will talk
   about implications of how to distinguish what cert chain to send.  It
   will describe how signature_algorithms extension will be used in TLS.
   What is missing in TLS and IKEv2 like what and how to sign something
   with the two private keys.  It will discuss overhead (size and
   processing) as in Section 8.  It will also discuss PKCS#10.

10.  IANA Considerations

   EDNOTE: This section will include content only if new OIDs or IANA
   codepoints are asigned for it.

   There are no IANA Considerations for this specification.  EDNOTE: ^^
   ?? Don't we need OIDs?








Kampanakis (Editor)      Expires August 6, 2019                [Page 10]

Internet-Draft               Composite Certs               February 2019


11.  Security Considerations

   EDNOTE: This section includes the Security Considerations.

   o  Case: Only one key is compromised.

   o  Case: An entire algorithm is compromised.

   o  CA implementations need to be careful when checking for
      compromised key reuse: unpack the CompositePublicKey structure and
      compare individual keys.

12.  Appendices

12.1.  Comparison with draft-truskovsky-lamps-pq-hybrid-x509

   EDNOTE: This section will explain the differences from
   [I-D.truskovsky-lamps-pq-hybrid-x509].  IPR Claims should be
   mentioned here if necessary.  Other things to consider are the things
   we discussed in an email thread like simplicity and format,
   inadvertnt implementation errors, algorithm agility.

   (MO): Move to appendix, or to a supporting document?

12.2.  Composite Encryption Algorithm

   While this draft does not directly cover ciphertext formats, the
   "encrypt with a composite public key" logic is somewhat less obvious
   than for signatures; a naive implementer might be tempted to encrypt
   the message with each public key separately, which is wrong.  We
   provide a sample algorithm for nesting composite encryptions.

   Input: K1, K2, ..., Kn The n private keys for the component signature
   algorithms M Message to be encrypted, an octet string

   Output: Ciphertext BIT STRING

   Encryption procedure:

13.  Contributors

   EDNOTE: This section includes the contributors of this draft so the
   authors in the first page do not exceed five and thus violate
   RFC2223-bis.  Example where this happens is RFC1122.  We can have
   another Editor for this draft.  Doesn't need to be Panos.

   This document incorporates contributions and comments from a large
   group of experts.  The Editor would especially like to acknowledge



Kampanakis (Editor)      Expires August 6, 2019                [Page 11]

Internet-Draft               Composite Certs               February 2019


   the tireless dedication of the following people, who attended many
   long meetings and generated millions of bytes of electronic mail over
   the past 3 years months in pursuit of this document: Mike Ounsworth
   (Entrust Datacard), John Gray (Entrust Datacard), Serge Mister
   (Entrust Datacard), Scott Fluhrer (Cisco Systems) and Panos
   Kampanakis (Cisco Systems).

   We are grateful to all, including any contributors who may have been
   inadvertently omitted from this list.

14.  Acknowledgenents

   EDNOTE: this section include all those that need to be acknowledged
   in the draft

15.  References

15.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS #10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              DOI 10.17487/RFC2986, November 2000,
              <https://www.rfc-editor.org/info/rfc2986>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

15.2.  Informative References

   [I-D.truskovsky-lamps-pq-hybrid-x509]
              Truskovsky, A., Geest, D., Fluhrer, S., Kampanakis, P.,
              Ounsworth, M., and S. Mister, "Multiple Public-Key
              Algorithm X.509 Certificates", draft-truskovsky-lamps-pq-
              hybrid-x509-01 (work in progress), August 2018.





Kampanakis (Editor)      Expires August 6, 2019                [Page 12]

Internet-Draft               Composite Certs               February 2019


Author's Address

   Panos Kampanakis
   Cisco Systems

   Email: pkampana@cisco.com













































Kampanakis (Editor)      Expires August 6, 2019                [Page 13]
